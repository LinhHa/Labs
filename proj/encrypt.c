#include <stdio.h>

#define ROW 4
#define COL 4
#define SIZE ROW * COL
void readFile(unsigned int *buffer);
void writeOut(unsigned int *buffer);
int convertChar(char c);
unsigned int convertToHex(char *number, int size);
unsigned int mult(int num, int times);
void convertToChar(unsigned int num, char *number, int size);

/**************************INPUT-OUTPUT****************************/
//NOTE: need a lot of changes here, this is for testing purpose
//break down into 16 bytes segments
//read key
//read files, supposed to be able to break down the file into segments of 16 bytes, but for testing purpose we go with converting to number first
void readFile (unsigned int *buffer) {
  char buf[ROW*COL*2] = {0};
  scanf("%s", buf);
  
  for (int i = 0; i < COL * ROW; i++) {
    char temp[2];
    temp[0] = buf[2*i];
    temp[1] = buf[2*i + 1];
    buffer[i] = convertToHex(temp, 2);
  }
}

//send back decrypted fragment
void writeOut (unsigned int *buffer) {
  for (int i = 0; i < COL * ROW; i++) {
    char temp[2];
    convertToChar(buffer[i], temp, 2);    
    printf("%s", temp);
  }
  printf("\n");
}

int convertChar (char c) {
  if (c >= 'a' && c <= 'f') {
    return (c - 'a') + 10;
  }
  if (c >= '0' && c <= '9') {
    return (c - '0');
  }
  return -1;
}

char convertInt (int n) {
  if (n >= 0 && n <= 9) {
    return n + '0';
  }
  if (n > 9 && n <= 15) {
    return (n - 10) + 'a';
  }
  return 0;
}

unsigned int convertToHex (char *number, int size) {
  int num = 0;
  for (int i = 0 ; i < size; i++) {
    int temp = convertChar(number[i]);
    if (temp == -1) {
      return 0;
    } else {
      num += temp * mult(16, size - i - 1);
    }
  }
  return (unsigned char)num;
}

void convertToChar (unsigned int num, char *number, int size) {
  int i = 0;
  while (i < size) {
    int m = num % 16;
    number[size - i - 1] = convertInt(m);
    num = num / 16;
    i++;
  }
}

//assume it is not too big to overflow the integer - which is most likely the case here. times is integer >= 0 only
unsigned int mult (int num, int times) {
  int acc = 1;
  for (int i = 0; i < times; i++) {
    acc *= num;
  }
  return acc;
}

/********************************************************************/

/************************DECRYPT-OPERATIONS**************************/
unsigned int keys[11][SIZE] = {};
unsigned int rcons[11] = {0x8d, 0x01, 0x02, 0x04, 0x08, 0x10,
			  0x20, 0x40, 0x80, 0x1b, 0x36};
unsigned int sbox[256] = 
 {
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
    0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
    0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
    0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
    0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
    0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
    0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
    0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
    0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
    0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
    0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
    0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
    0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
    0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
    0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
    0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
 };

//should try memcpy here?
void copyKey (unsigned int *toCopy, unsigned int *dest) {
  for (int i = 0; i < SIZE; i++) {
    dest[i] = toCopy[i];
  }
}

void transform (unsigned int *col, int ord) {
  unsigned int temp[ROW];
  for (int i = 0; i < ROW; i++) {
    temp[i] = sbox[col[i]];
  }
  for (int i = 0; i < ROW; i++) {
    col[i] = temp[(i+1)%ROW];
  }
  col[0] ^= rcons[ord];
}

//expand key
void expandKey (unsigned int *init) {
  copyKey(init, keys[0]);
  for (int i = 1; i < 11; i++) {
    unsigned int temp[SIZE], prev[SIZE];    
    copyKey(keys[i - 1], temp);
    copyKey(temp, prev);    
    transform(temp + 3 * COL, i);
    for (int j = 0; j < COL; j++) {
      if (j == 0) {	
	for (int k = 0; k < ROW; k++) {
	  temp[k] = temp[(j + 3) * COL + k] ^ prev[k];
	}
      }
      else {
	for (int k = 0; k < ROW; k++) {
	  temp[j * COL + k] = temp[(j - 1) * COL + k] ^ prev[j * COL + k];
	}
      }
    }
    copyKey(temp, keys[i]);
  }
}

//decrypt for each segment : 10 rounds, 4 operations

unsigned int inv[256] = 
 {
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
    0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
    0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
    0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
    0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
    0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
    0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
    0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
    0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
    0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
    0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
    0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
    0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
    0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
    0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
    0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
    0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
 };

//generate sbox or hard-coded? (substitute bytes)
void subBytes (unsigned int *mes) {
  for (int i = 0; i < SIZE; i++) {
    mes[i] = inv[mes[i]];
  }
}

unsigned int multTwo (unsigned int num) {
  return (((num << 1) ^ (num & 0x80 ? 27 : 0)) & 0xff);
}

//mix columns: multiplying takes 4*3 + 8 = 20 instructions per number
//look up using log table takes around 4~5 -- consider switching
//if using log table, it is also possible to get rid of the sbox and inverse sbox, of course at the cost of more instructions 
void mixCol (unsigned int *mes) {
  int op[ROW][COL] = {{3, 1, 2, 0}, {0, 3, 1, 2},
		      {2, 0, 3, 1}, {1, 2, 0, 3}};
  unsigned int lutMes[SIZE][4];
  for (int i = 0 ; i < SIZE; i++) {
    unsigned int mult2 = multTwo(mes[i]);
    unsigned int mult4 = multTwo(mult2);
    unsigned int mult8 = multTwo(mult4);
    lutMes[i][0] = mult8 ^ mes[i];
    lutMes[i][1] = lutMes[i][0] ^ mult2;
    lutMes[i][2] = lutMes[i][0] ^ mult4;
    lutMes[i][3] = mult8 ^ mult4 ^ mult2;
  }

  for (int i = 0; i < COL; i++) {
    for (int j = 0; j < ROW; j++) {
      int ind = i * COL;
      unsigned int acc = 0;
      for (int k = 0; k < ROW; k++) {
	acc ^= lutMes[ind + k][op[j][k]];
      }
      mes[ind + j] = acc;
    }
  }
}

//shift rows: can be combined with sub bytes.
void shiftRows (unsigned int *mes) {
  unsigned int temp[SIZE];
  int shuffles[SIZE] = {0, 13, 10, 7, 4, 1, 14, 11,
			8, 5, 2, 15, 12, 9, 6, 3};
  for (int i = 0; i < SIZE; i++) {
    temp[i] = mes[i];
  }
  for (int i = 0; i < SIZE; i++) {
    mes[i] = temp[shuffles[i]];
  }
}

//add round: need separate xor operation? modify in place better?
//assume the input is properly processed, which is 4x4 matrix
void addRound (unsigned int *mes, unsigned int *key) {
  for (int i = 0; i < COL * ROW; i++) {
    mes[i] = mes[i] ^ key[i];
  }
}

void decrypt (unsigned int *mes) {
  for (int i = 1; i < 11; i++) {
    if (i == 1) {
      addRound(mes, keys[10]);
      shiftRows(mes);
      subBytes(mes);
    }
    else {
      addRound(mes, keys[11 - i]);
      mixCol(mes);
      shiftRows(mes);
      subBytes(mes);
    }
  }
  addRound(mes, keys[0]);
}

//test
int main(void) {
  unsigned int buffer[ROW * COL];
  unsigned int key[ROW*COL];
  readFile(key);
  expandKey(key);
  readFile(buffer);
  decrypt(buffer);
  writeOut(buffer);

  return 0;
}
